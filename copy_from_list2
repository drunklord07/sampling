#!/usr/bin/env python3
import os
import shutil
import sys
import re
from collections import Counter

# Extensions allowed for one-file-per-folder copying
ALLOWED_EXTS = ['.tar.xz', '.gz', '.log', '.txt', '.zip', '.xz', '.log_secure']

def sanitize_name(name, existing):
    """Ensure folder name is unique in output/"""
    if name not in existing:
        existing[name] = 1
        return name
    else:
        existing[name] += 1
        return f"{name}{existing[name]}"

def get_matched_ext(filename):
    """
    Returns the recognized extension, treating rotated logs and .log_secure specially.
    """
    if filename.endswith('.log_secure'):
        return '.log_secure'
    if re.search(r'\.log(\.\d+)?$', filename):
        return '.log'
    if re.search(r'\.log[-_.]?\d{4}[-_.]?\d{2}[-_.]?\d{2}', filename):
        return '.log'
    return os.path.splitext(filename)[1].lower()

def copy_one_of_each(src_folder, dest_folder, unknown_files, counts, skipped_files):
    copied = 0
    already_copied = set()

    try:
        entries = os.listdir(src_folder)
    except PermissionError:
        raise

    for name in entries:
        src = os.path.join(src_folder, name)
        if not os.path.isfile(src):
            continue

        ext = get_matched_ext(name)

        if ext in ALLOWED_EXTS and ext not in already_copied:
            dst = os.path.join(dest_folder, name)
            try:
                os.makedirs(os.path.dirname(dst), exist_ok=True)
                shutil.copy2(src, dst)
                counts[ext] += 1
                copied += 1
                already_copied.add(ext)
                print(f"Copied ({ext}): {src} → {dst}")
            except Exception as e:
                skipped_files.append((src, str(e)))
                print(f"❌ Failed to copy {src}: {e}")

    for name in entries:
        path = os.path.join(src_folder, name)
        if os.path.isfile(path):
            ext = get_matched_ext(name)
            if ext not in ALLOWED_EXTS:
                actual_ext = os.path.splitext(name)[1] or '(no ext)'
                unknown_files.append((path, actual_ext))
                counts['unknown'] += 1

    return copied

def process_path(source_root, output_base, unknown_files, skipped_dirs, skipped_files,
                 counts, total_stats, input_root_prefix):
    if not os.path.isdir(source_root):
        skipped_dirs.append((source_root, "Not a directory or does not exist"))
        return

    for root, dirs, files in os.walk(source_root):
        total_stats['folders'] += 1
        total_stats['files_found'] += len(files)

        # Maintain full relative path starting from input_root_prefix
        try:
            rel_path = os.path.relpath(root, input_root_prefix)
            dest_folder = os.path.join(output_base, rel_path)
        except Exception as e:
            skipped_dirs.append((root, f"Failed to compute relative path: {e}"))
            continue

        try:
            os.makedirs(dest_folder, exist_ok=True)
        except Exception as e:
            skipped_dirs.append((dest_folder, f"Cannot create folder: {e}"))
            continue

        try:
            copied = copy_one_of_each(root, dest_folder, unknown_files, counts, skipped_files)
            total_stats['files_copied'] += copied
        except PermissionError as e:
            skipped_dirs.append((root, f"Permission denied: {e}"))

def read_input_paths(file_path):
    with open(file_path, "r") as f:
        return [line.strip() for line in f if line.strip() and not line.strip().startswith("#")]

def main(input_file):
    input_paths = read_input_paths(input_file)
    output_base = os.path.join(os.getcwd(), "output")
    os.makedirs(output_base, exist_ok=True)

    unknown_files = []
    skipped_dirs = []
    skipped_files = []
    counts = Counter({ext: 0 for ext in ALLOWED_EXTS})
    counts['unknown'] = 0
    folder_rename_map = {}
    folder_mapping = {}
    total_stats = {
        'folders': 0,
        'files_found': 0,
        'files_copied': 0,
        'input_paths': len(input_paths),
        'valid_paths': 0,
        'skipped_paths': 0,
    }

    for path in input_paths:
        if not os.path.isdir(path):
            skipped_dirs.append((path, "Invalid path (not a directory)"))
            total_stats['skipped_paths'] += 1
            continue

        total_stats['valid_paths'] += 1

        # Reconstruct full path under output
        abs_input_path = os.path.abspath(path)
        dest_root = os.path.join(output_base, os.path.relpath(abs_input_path, '/'))

        process_path(abs_input_path, dest_root, unknown_files, skipped_dirs, skipped_files,
                     counts, total_stats, abs_input_path)

    # Write all_done.txt
    with open("all_done.txt", "w") as f:
        f.write("========= COPY SUMMARY =========\n")
        f.write(f"Total input paths:           {total_stats['input_paths']}\n")
        f.write(f"Valid input paths:           {total_stats['valid_paths']}\n")
        f.write(f"Skipped/invalid input paths: {total_stats['skipped_paths']}\n")
        f.write(f"Total folders visited:       {total_stats['folders']}\n")
        f.write(f"Total files scanned:         {total_stats['files_found']}\n")
        f.write(f"Total files copied:          {total_stats['files_copied']}\n")
        f.write(f"Total unknown extension files:{counts['unknown']}\n")
        f.write(f"Total skipped file copies:   {len(skipped_files)}\n\n")
        f.write("========= FILES COPIED BY TYPE =========\n")
        for ext in ALLOWED_EXTS:
            f.write(f"{ext:>12} : {counts[ext]}\n")
        f.write(f"{'unknown':>12} : {counts['unknown']}\n")

    if skipped_dirs or skipped_files:
        with open("skipped_folders.txt", "w") as f:
            if skipped_dirs:
                f.write("Folders skipped due to error or access issues:\n")
                for folder, reason in skipped_dirs:
                    f.write(f"{folder}  →  {reason}\n")
                f.write("\n")
            if skipped_files:
                f.write("Files skipped due to copy failures:\n")
                for file_path, err in skipped_files:
                    f.write(f"{file_path}  →  {err}\n")

    if unknown_files:
        with open("unknown_files.txt", "w") as f:
            f.write("Files with unapproved or unknown extensions:\n")
            for file_path, ext in unknown_files:
                f.write(f"{file_path}  →  {ext}\n")

    print("\n✅ DONE. See logs: all_done.txt, skipped_folders.txt, unknown_files.txt")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 copy_from_paths.py input_paths.txt")
    else:
        main(sys.argv[1])
